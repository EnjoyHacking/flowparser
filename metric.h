#ifndef FPARSER_METRIC_H
#define FPARSER_METRIC_H

#include <tuple>
#include <array>
#include <chrono>
#include <mutex>

#include "common.h"
#include "periodic_runner.h"

namespace flowparser {

// Lifted from http://www.exploringbinary.com
constexpr int IsPowerOfTwo(uint32_t x) {
  return ((x != 0) && ((x & (~x + 1)) == x));
}

// A class that knows how to consume metric values. This template should have
// the same arguments as the metric it consumes.
template<typename First, typename ... Rest>
class MetricConsumer {
 public:
  // A value recorded in a matric. The first element is an id, all values
  // generated by the same metric will have unique ids. The second is a UNIX
  // timestamp. The actual types being recorded follow.
  typedef std::tuple<uint64_t, uint64_t, First, Rest...> StampedMetricValue;

  virtual ~MetricConsumer() {
  }

  // Consumes a history of values. The input vector is chronologically ordered
  // - the last value is the most recent one.
  virtual void ConsumeHistory(
      const std::vector<StampedMetricValue>& values) = 0;

 protected:
  MetricConsumer() {
  }

 private:

  DISALLOW_COPY_AND_ASSIGN(MetricConsumer);
};

template<size_t HSize, typename First, typename ... Rest>
class Metric {
 public:
  // How much history is to be retained in memory between flush events.
  static constexpr size_t kHistorySize = HSize;

  // A value to be recorded in this metric.
  typedef typename MetricConsumer<First, Rest...>::StampedMetricValue StampedMetricValue;

  // Returns the id of a value.
  static constexpr size_t Id(const StampedMetricValue& value) {
    return std::get<0>(value);
  }

  // Returns the timestamp of a value.
  static constexpr time_t Timestamp(const StampedMetricValue& value) {
    return static_cast<time_t>(std::get<1>(value));
  }

  Metric()
      : id_(0),
        epoch_id_(0) {
    static_assert(IsPowerOfTwo(HSize), "History size must be a power of 2");
  }

  // The most recent value inserted this epoch. If there are no values inserted
  // non-ok status is returned.
  ValueOrError<StampedMetricValue> MostRecent() {
    std::unique_lock<std::mutex> lock(mu_);
    if (id_ == 0) {
      return "History empty";
    }

    size_t index = (id_ - 1) & kMask;
    return values_[index];
  }

  // Feeds the history to a consumer and ends the current epoch.
  void ConsumeHistoryAndEndEpoch(MetricConsumer<First, Rest...>* consumer) {
    std::vector<StampedMetricValue> history;

    {
      std::unique_lock<std::mutex> lock(mu_);

      uint64_t size = kHistorySize;
      uint64_t start = id_ - kHistorySize;
      if (id_ < kHistorySize) {
        size = id_;
        start = 0;
      }

      history.reserve(size);

      for (uint64_t i = start; i < start + size; ++i) {
        history.push_back(values_[i & kMask]);
      }

      // Reset the epoch.
      id_ = 0;
      epoch_id_++;
    }

    consumer->ConsumeHistory(history);
  }

 protected:
  // Adds a new value to this metric. If the number of values in history is
  // equal to kHistorySize the oldest one will be discarded. The new value is
  // given a unique increasing id and is timestamped. This method is protected
  // as opposed to virtual since it will potentially be called often.
  // Implementations should have their own AddValue method which calls this one.
  void ProtectedAddValue(First first, Rest ... rest) {
    auto now = std::chrono::system_clock::now().time_since_epoch();
    uint64_t timestamp = std::chrono::duration_cast<std::chrono::seconds>(now)
        .count();

    std::unique_lock<std::mutex> lock(mu_);
    uint64_t combined_id = static_cast<uint64_t>(epoch_id_) << 32 | id_;
    values_[id_++ & kMask] = std::make_tuple(combined_id, timestamp, first,
                                             rest...);
  }

 private:
  static constexpr size_t kMask = kHistorySize - 1;

  // A mutex to protect the metric.
  std::mutex mu_;

  // A unique id for values within the epoch.
  uint32_t id_;

  // A unique id for epochs.
  uint32_t epoch_id_;

  // Values are stored in a constant-size array.
  std::array<StampedMetricValue, HSize> values_;
};

// A metric manager is responsible for periodically collecting a metric's
// history and handing it to all registered consumers. There is one
// MetricManager per metric. It has ownership of the consumers, but the metric
// itself is shared between this class and any other class that needs to produce
// values.
template<size_t HSize, typename First, typename ... Rest>
class MetricManager {
 public:
  typedef std::unique_ptr<MetricConsumer<First, Rest ...>> ConsumerPtr;
  typedef std::shared_ptr<Metric<HSize, First, Rest...>> MetricPtr;

  MetricManager(MetricPtr metric, std::chrono::milliseconds period_ms)
      : metric_(metric),
        consumer_task_([this] {ConsumeMetric();}, period_ms) {
  }

  // Adds a new consumer.
  void RegisterConsumer(ConsumerPtr consumer) {
    consumers_.push_back(std::move(consumer));
  }

  void Start() {
    consumer_task_.Start();
  }

  void Stop() {
    consumer_task_.Stop();
    ConsumeMetric();
  }

  void ConsumeMetric() {
    for (const auto& consumer : consumers_) {
      metric_->ConsumeHistoryAndEndEpoch(consumer.get());
    }
  }

 private:
  // The consumers
  std::vector<ConsumerPtr> consumers_;

  // The metric to manage
  MetricPtr metric_;

  // A periodic task to consume values from the metric.
  PeriodicTask consumer_task_;
};

}

#endif  /* FPARSER_METRIC_H */
