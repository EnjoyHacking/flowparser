#ifndef FPARSER_METRIC_EXPORTER_H
#define FPARSER_METRIC_EXPORTER_H

#include <tuple>
#include <array>
#include <chrono>

#include "common.h"

namespace flowparser {

template<size_t HSize, typename First, typename ... Rest>
class Metric {
 public:
  static constexpr size_t kHistorySize = HSize;

  // A collection of values recorded by the metric.
  typedef std::tuple<First, Rest> MetricValue;

  Metric()
      : id_(0) {
  }

  void AddValue(First first, Rest ... rest) {
    size_t index = id_ % kHistorySize;

    auto now = std::chrono::system_clock::now().time_since_epoch();
    uint64_t timestamp = std::chrono::duration_cast<std::chrono::seconds>(now);

    values_[index] = std::make_tuple(++id_, timestamp,
                                     std::make_tuple(first, rest));
  }

  ValueOrError<MetricValue> MostRecent() {
    if (id_ == 0) {
      return "History empty";
    }

    size_t index = (id_ - 1) % kHistorySize;
    return std::get<2>(values_[index]);
  }

 private:
  // A value to be recorded in this metric. The first element is an id, all
  // values generated by the same metric will have unique ids. The second is a
  // UNIX timestamp. The actual types being recorded follow.
  typedef std::tuple<uint64_t, uint64_t, MetricValue> StampedMetricValue;

  uint64_t id_;

  std::array<StampedMetricValue, HSize> values_;
};

}
