#ifndef FPARSER_METRIC_EXPORTER_H
#define FPARSER_METRIC_EXPORTER_H

#include <tuple>
#include <array>
#include <chrono>

#include "common.h"
#include "periodic_runner.h"

namespace flowparser {

// A class that knows how to consume metric values. This template should have
// the same arguments as the metric it consumes.
template<typename First, typename ... Rest>
class MetricConsumer {
 public:
  // A value recorded in a matric. The first element is an id, all values
  // generated by the same metric will have unique ids. The second is a UNIX
  // timestamp. The actual types being recorded follow.
  typedef std::tuple<uint64_t, uint64_t, First, Rest...> StampedMetricValue;

  virtual ~MetricConsumer() {
  }

  // Consumes a history of values. The input vector is chronologically ordered
  // - the last value is the most recent one.
  virtual void ConsumeHistory(
      const std::vector<StampedMetricValue>& values) = 0;

 protected:
  MetricConsumer() {
  }

 private:

  DISALLOW_COPY_AND_ASSIGN(MetricConsumer);
};

template<size_t HSize, typename First, typename ... Rest>
class Metric {
 public:
  // How much history is to be retained in memory between flush events.
  static constexpr size_t kHistorySize = HSize;

  // A value to be recorded in this metric.
  typedef typename MetricConsumer<First, Rest...>::StampedMetricValue StampedMetricValue;

  // Returns the id of a value.
  static constexpr size_t Id(const StampedMetricValue& value) {
    return std::get<0>(value);
  }

  // Returns the timestamp of a value.
  static constexpr size_t Timestamp(const StampedMetricValue& value) {
    return std::get<1>(value);
  }

  Metric()
      : id_(0),
        epoch_id_(0) {
    static_assert(HSize > 0, "History size must be greater than 0");
  }

  // The most recent value inserted this epoch. If there are no values inserted
  // non-ok status is returned.
  ValueOrError<StampedMetricValue> MostRecent() const {
    if (id_ == 0) {
      return "History empty";
    }

    size_t index = (id_ - 1) % kHistorySize;
    return values_[index];
  }

  // A copy of the history. The returned vector will have at most kHistorySize
  // elements.
  std::vector<StampedMetricValue> HistoryCopy() const {
    uint64_t size = kHistorySize;
    uint64_t start = id_ - kHistorySize;
    if (id_ < kHistorySize) {
      size = id_;
      start = 0;
    }

    std::vector<StampedMetricValue> return_vector;
    return_vector.reserve(size);

    for (uint64_t i = start; i < start + size; ++i) {
      size_t index = i % kHistorySize;

      return_vector.push_back(values_[index]);
    }

    return return_vector;
  }

  // Starts a new epoch and resets the history.
  void NewEpoch() {
    id_ = 0;
    epoch_id_++;
  }

  // Feeds the history to a consumer and ends the current epoch.
  void ConsumeHistoryAndEndEpoch(MetricConsumer<First, Rest...>* consumer) {
    std::vector<StampedMetricValue> history = HistoryCopy();

    NewEpoch();
    consumer->ConsumeHistory(history);
  }

 protected:
  // Adds a new value to this metric. If the number of values in history is
  // equal to kHistorySize the oldest one will be discarded. The new value is
  // given a unique increasing id and is timestamped. This method is protected
  // as opposed to virtual since it will potentially be called often.
  // Implementations should have their own AddValue method which calls this one.
  void ProtectedAddValue(First first, Rest ... rest) {
    size_t index = id_ % kHistorySize;

    auto now = std::chrono::system_clock::now().time_since_epoch();
    uint64_t timestamp = std::chrono::duration_cast<std::chrono::seconds>(now)
        .count();

    uint64_t id = static_cast<uint64_t>(epoch_id_) << 32 | ++id_;
    values_[index] = std::make_tuple(id, timestamp, first, rest...);
  }

 private:
  // A unique id for values within the epoch.
  uint32_t id_;

  // A unique id for epochs.
  uint32_t epoch_id_;

  // Values are stored in a constant-size array.
  std::array<StampedMetricValue, HSize> values_;
};

// A percent metric. The value supplied should be in the 0-1 range, if it is
// not then it will be truncated.
class PercentMetric : public Metric<1000, double> {
  void AddValue(double value) {
    if (value > 1.0) {
      value = 1.0;
    }

    if (value < 0.0) {
      value = 0.0;
    }

    Metric<1000, double>::ProtectedAddValue(value);
  }
};

// Severity levels for log messages.
enum LogLevel {
  DEBUG,
  INFO,
  WARN,
  ERROR
};

// A metric that records log messages.
class LogMetric : public Metric<1000, LogLevel, std::string> {
  void AddValue(enum LogLevel log_level, std::string message) {
    Metric<1000, LogLevel, std::string>::ProtectedAddValue(log_level, message);
  }
};

class ConsoleLogMetricConsumer : public MetricConsumer<LogLevel, std::string> {
  void ConsumeHistory(const std::vector<StampedMetricValue>& values) override {

  }
};

// A metric manager is responsible for periodically collecting a metric's
// history and handing it to all registered consumers. There is one
// MetricManager per metric. It has ownership of the consumers, but the metric
// itself is shared between this class and any other class that needs to produce
// values.
template<size_t HSize, typename First, typename ... Rest>
class MetricManager {
 public:
  typedef std::unique_ptr<MetricConsumer<First, Rest ...>> ConsumerPtr;
  typedef std::shared_ptr<Metric<HSize, First, Rest...>> MetricPtr;

  MetricManager(MetricPtr metric, std::chrono::milliseconds period_ms)
      : metric_(metric),
        consumer_task_([this] {ConsumeMetric();}, period_ms) {
  }

  // Adds a new consumer.
  void RegisterConsumer(ConsumerPtr consumer) {
    consumers_.push_back(std::move(consumer));
  }

  void Start() {
    consumer_task_.Start();
  }

  void Stop() {
    consumer_task_.Stop();
    ConsumeMetric();
  }

 private:

  void ConsumeMetric() {
    for (const auto& consumer : consumers_) {
      metric_->ConsumeHistoryAndEndEpoch(consumer.get());
    }
  }

  // The consumers
  std::vector<ConsumerPtr> consumers_;

  // The metric to manage
  MetricPtr metric_;

  // A periodic task to consume values from the metric.
  PeriodicTask consumer_task_;
};

}

#endif  /* FPARSER_METRIC_EXPORTER_H */
